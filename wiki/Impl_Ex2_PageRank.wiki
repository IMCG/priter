#summary PageRank implementation with priority

= Introduction =

PageRank algorithm is widely used for many applications such as web search and personalized recommendation. The PageRank algorithm assumes that a user starts at a page with equal probability and performs random walk on the web linkage graph. 

To extract priority property from PageRank problem, we change PageRank to another form, which will get the same results. The changed PageRank form is called incremental PageRank, which does not iterate ranking score but iterate a delta ranking score. These partial delta is accumulated to get a final ranking score. 

= Details =

*_Activator_* 
{{{
public class PageRankActivator extends PrIterBase implements
	Activator<IntWritable, FloatWritable, FloatWritable> {

	private String subGraphsDir;
	private int iter = 0;
	private int kvs = 0;				//for tracking
	private int partitions;
	
	//graph in local memory
	private HashMap<Integer, ArrayList<Integer>> linkList = new HashMap<Integer, ArrayList<Integer>>();
	
	private synchronized void loadGraphToMem(JobConf conf, int n){
		subGraphsDir = conf.get(MainDriver.SUBGRAPH_DIR);
		Path subgraph = new Path(subGraphsDir + "/part" + n);
		
		FileSystem hdfs = null;
	    try {
			hdfs = FileSystem.get(conf);
			FSDataInputStream in = hdfs.open(subgraph);
			BufferedReader reader = new BufferedReader(new InputStreamReader(in));
			
			String line;
			while((line = reader.readLine()) != null){
				int index = line.indexOf("\t");
				if(index != -1){
					String node = line.substring(0, index);
					
					String linkstring = line.substring(index+1);
					ArrayList<Integer> links = new ArrayList<Integer>();
					StringTokenizer st = new StringTokenizer(linkstring);
					while(st.hasMoreTokens()){
						links.add(Integer.parseInt(st.nextToken()));
					}
					
					this.linkList.put(Integer.parseInt(node), links);
				}
			}
			reader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void configure(JobConf job) {
		int taskid = Util.getTaskId(job);
		partitions = job.getInt("priter.graph.partitions", 1);
		loadGraphToMem(job, taskid);
	}
	
	@Override
	public void initStarter(InputPKVBuffer<IntWritable, FloatWritable> starter) throws IOException {	
		for(int k : linkList.keySet()){
			starter.init(new IntWritable(k), new FloatWritable(PageRank.RETAINFAC));
		}
	}

	@Override
	public void activate(IntWritable key, FloatWritable value,
			OutputCollector<IntWritable, FloatWritable> output, Reporter report)
			throws IOException {
		kvs++;
		report.setStatus(String.valueOf(kvs));
		
		int page = key.get();
		ArrayList<Integer> links = null;
		links = this.linkList.get(key.get());

		if(links == null){
			System.out.println("no links found for page " + page);
			for(int i=0; i<partitions; i++){
				output.collect(new IntWritable(i), new FloatWritable(0));
			}
			return;
		}	
		float delta = value.get() * PageRank.DAMPINGFAC / links.size();
		
		for(int link : links){
			output.collect(new IntWritable(link), new FloatWritable(delta));
		}	
	}

	@Override
	public void iterate() {
		System.out.println((iter++) + " passes " + kvs + " activations");
	}
}

}}}

*_Updator_*
{{{
public class PageRankUpdator extends PrIterBase implements Updator<IntWritable, DoubleWritable> {
    public void updateState(IntWritable node, DoubleWritable value, OutputPKVBuffer<IntWritable, DoubleWritable> buffer, Reporter report){
        int nodeid = node.get();
        double deltaR = value.get();
    
        PriorityRecord<IntWritable, DoubleWritable> pkvRecord;	
	if(buffer.stateTable.containsKey(node)){
	    pkvRecord = buffer.stateTable.get(node);
	    double iState = pkvRecord.getiState().get() + deltaR;
	    double cState = pkvRecord.getcState().get() + deltaR;
   	    buffer.stateTable.get(node).getiState().set(iState);
            buffer.stateTable.get(node).getcState().set(cState);
	    buffer.stateTable.get(node).getPriority().set(iState);
        }else{
	    pkvRecord = new PriorityRecord<DoubleWritable, DoubleWritable>(
	    new DoubleWritable(deltaR), new DoubleWritable(deltaR), new DoubleWritable(deltaR));
	    buffer.stateTable.put(new IntWritable(nodeid), pkvRecord);
	}
    }

    public IntWritable decidePriority(IntWritable node, DoubleWritable deltaR, boolean iornot){
        return new IntWritable(deltaR);
    }
}
}}}

*_Main_*
{{{
public class PageRank{
    public static void main(String[] args){
        Job job = new Job();

        FileOutputFormat.setOutputPath(job, new Path("PageRank_output"));
        job.setOutputFormat(TextOutputFormat.class);

        job.setBoolean("priter.job", true);
        job.set("priter.graph.path", "PageRank_input/google_graph");
        job.set("priter.graph.starter.path", "PageRank_input/google_startpages");
        job.setInt("priter.graph.partitions", 4);	
        job.setInt("priter.graph.nodes", 875713);
        job.setLong("priter.snapshot.interval", 20000);
        job.setInt("priter.snapshot.topk", 1000);
        job.setInt("priter.queue.portion", 0.2);
        job.setFloat("priter.stop.difference", 1);	

        job.setJarByClass(PageRank.class);
        job.setActivatorClass(PageRankActivator.class);	
        job.setUpdatorClass(PageRankUpdator.class);
        job.setMapOutputKeyClass(IntWritable.class);
        job.setMapOutputValueClass(DoubleWritable.class);
        job.setOutputKeyClass(IntWritable.class);
        job.setOutputValueClass(DoubleWritable.class);
        job.setPriorityClass(DoubleWritable.class);      

        jobClient.runJob(job);
    }
}
}}}