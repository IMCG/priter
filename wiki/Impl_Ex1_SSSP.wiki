#summary Single Source Shortest Path implementation with priority.

= Introduction =
SSSP problem is a classical problem that derives the shortest distance from a source node to other nodes in a graph. Under a parallel computing environment, the most straightforward approach to find the shortest distance is to use breadth first search (BFS).

In the MapReduce model, each iteration performs the above computation for all nodes. As a result, iteration _i_ computes the shortest distance up to _i_ hops away. However, as we can see from Dijsktra's algorithm, it is more efficient if we expand the node with the shortest distance first since it is more likely that node has already determine its shortest distance. Therefore, a prioritized execution of the iterative process is desirable.

A prioritized execution of the SSSP algorithm can be described as follows. In each iteration, only a subset of nodes perform the iterative computation. The selection of the subset is according to a priority. First, a node is eligible to perform the iterative computation only if it has obtained a shorter distance since its last time the iterative computation is performed on the node. Second, among all eligible nodes, the nodes with shorter distance have a higher priority to be activated to send its distance to its neighbors. Third, when the iterative operation is performed on a node, the node gets the distance values from neighboring nodes only if the neighboring nodes were activated since the node was last activated. The operation derives the shortest distance for the node among all distance values received. 

= Details =

*_Activator_* 
{{{
public class SSSPActivator extends PrIterBase implements Activator<IntWritable> {
    private HashMap<Integer, ArrayList<Link>> graph;
    private int startNode;
    private int activatedTimes = 0;
    private int activatedNodes = 0;

    public void configure(JobConf job){
        String graphPath = job.get("priter.graph.path");
        graph = loadWeightedGraph(graphPath);
        startNode = job.get("priter.sssp.startnode");
    }

    public void initStarter(ActivateBuffer<IntWritable> starter) {
        starter.init(new IntWritable(startNode), new IntWritable(0));
    }

    public void activate(IntWritable node, IntWritable value, OutputCollector<IntWritable, IntWritable> output, Reporter report){
        int nodeid = node.get();
        int distance = value.get();
        ArrayList<Integer> linklist = graph.get(nodeid);

        for(Link link: linklist){
            output.collect(new IntWritable(link.end), new IntWritable(distance+link.length));
        }

        activatedNodes++;
    }

    public void iterate(){
        activatedTimes++;
        System.out.println("activate times: " + activatedTime + ", total activated node: " + activatedNode);
    }
}
}}}

*_Updator_*
{{{
public class SSSPUpdator extends PrIterBase implements Updator<IntWritable, IntWritable> {
    private int iteration = 0;

    public void initStateTable(OutputPKVBuffer<IntWritable, IntWritable> buffer){
    }

    public void updateState(IntWritable node, IntWritable value, OutputPKVBuffer<IntWritable, IntWritable> buffer, Reporter report){
    int nodeid = node.get();
    int distance = value.get();
    
    PriorityRecord<IntWritable, IntWritable> pkvRecord;	
    if(buffer.stateTable.containsKey(node)){
        pkvRecord = buffer.stateTable.get(node);
	int cState = pkvRecord.getcState().get();
	if(distance < cState){
            buffer.stateTable.get(key).getiState().set(distance);
	    buffer.stateTable.get(key).getcState().set(distance);
	    buffer.stateTable.get(key).getPriority().set(-distance);
	}else{
	    pkvRecord = new PriorityRecord<IntWritable, IntWritable>(new IntWritable(-distance), new IntWritable(distance), new IntWritable(distance));
	    buffer.stateTable.put(node, pkvRecord);
	}
}

    public IntWritable decidePriority(IntWritable node, IntWritable distance, boolean iornot){
        return new IntWritable(-distance.get());
    }
}
}}}

*_Main_*

{{{
Job job = new Job();
job.setMap(Map);
job.setReduce(Reduce);
job.setStaticDataPath(graphpath);
job.setInitState(InitStateTable);
job.setState(StateUpdate);
job.setPriority(PriorityDecision);
job.setFactorc(10);
job.setTopK(10000);
job.setSnapshotInterval(5);
job.submit();
}}}